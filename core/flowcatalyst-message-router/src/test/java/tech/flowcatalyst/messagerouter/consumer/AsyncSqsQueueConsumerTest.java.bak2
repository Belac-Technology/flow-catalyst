package tech.flowcatalyst.messagerouter.consumer;

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterEach;
import software.amazon.awssdk.services.sqs.SqsAsyncClient;
import software.amazon.awssdk.services.sqs.model.*;
import tech.flowcatalyst.messagerouter.callback.MessageCallback;
import tech.flowcatalyst.messagerouter.manager.QueueManager;
import tech.flowcatalyst.messagerouter.metrics.QueueMetricsService;
import tech.flowcatalyst.messagerouter.model.MessagePointer;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import static org.awaitility.Awaitility.await;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for AsyncSqsQueueConsumer.
 * Tests async polling behavior, message processing, and graceful shutdown.
 */
@QuarkusTest
class AsyncSqsQueueConsumerTest {

    private AsyncSqsQueueConsumer asyncConsumer;
    private SqsAsyncClient mockSqsAsyncClient;
    private QueueManager mockQueueManager;
    private QueueMetricsService mockQueueMetrics;
    private tech.flowcatalyst.messagerouter.warning.WarningService mockWarningService;

    private final String queueUrl = "https://sqs.us-east-1.amazonaws.com/123456789/test-queue";

    @BeforeEach
    void setUp() {
        mockSqsAsyncClient = mock(SqsAsyncClient.class);
        mockQueueManager = mock(QueueManager.class);
        mockQueueMetrics = mock(QueueMetricsService.class);
        mockWarningService = mock(tech.flowcatalyst.messagerouter.warning.WarningService.class);

        asyncConsumer = new AsyncSqsQueueConsumer(
            mockSqsAsyncClient,
            queueUrl,
            2, // 2 concurrent polling tasks
            mockQueueManager,
            mockQueueMetrics,
            mockWarningService,
            10, // maxMessagesPerPoll
            20, // waitTimeSeconds
            5   // metricsPollIntervalSeconds
        );
    }

    @AfterEach
    void tearDown() {
        if (asyncConsumer != null) {
            asyncConsumer.stop();
        }
    }

    @Test
    void shouldPollAndProcessMessagesAsynchronously() {
        // Given
        String messageBody = """
            {
                "id": "async-msg-1",
                "poolCode": "POOL-A",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test"
            }
            """;

        Message sqsMessage = Message.builder()
            .body(messageBody)
            .receiptHandle("receipt-async-123")
            .build();

        ReceiveMessageResponse response = ReceiveMessageResponse.builder()
            .messages(sqsMessage)
            .build();

        // Mock returns message on first call, then empty responses
        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(response))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockQueueManager.routeMessageBatch(anyList())).thenReturn(true);

        // When
        asyncConsumer.start();

        // Then - verify async processing happens
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            verify(mockQueueManager, atLeastOnce()).routeMessageBatch(
                any(MessagePointer.class),
                any(MessageCallback.class)
            );
            verify(mockQueueMetrics, atLeastOnce()).recordMessageReceived(queueUrl);
        });
    }

    @Test
    void shouldProcessMultipleMessagesImmediately() {
        // Given - batch of messages
        String messageBody1 = """
            {
                "id": "async-msg-1",
                "poolCode": "POOL-A",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test1"
            }
            """;

        String messageBody2 = """
            {
                "id": "async-msg-2",
                "poolCode": "POOL-B",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test2"
            }
            """;

        Message sqsMessage1 = Message.builder()
            .body(messageBody1)
            .receiptHandle("receipt-1")
            .build();

        Message sqsMessage2 = Message.builder()
            .body(messageBody2)
            .receiptHandle("receipt-2")
            .build();

        ReceiveMessageResponse response = ReceiveMessageResponse.builder()
            .messages(sqsMessage1, sqsMessage2)
            .build();

        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(response))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockQueueManager.routeMessageBatch(anyList())).thenReturn(true);

        // When
        asyncConsumer.start();

        // Then - both messages processed
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            verify(mockQueueManager, times(2)).routeMessageBatch(
                any(MessagePointer.class),
                any(MessageCallback.class)
            );
            verify(mockQueueMetrics, times(2)).recordMessageReceived(queueUrl);
        });
    }

    @Test
    void shouldDeleteMessageOnAsyncAck() {
        // Given
        String messageBody = """
            {
                "id": "ack-msg",
                "poolCode": "POOL-A",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test"
            }
            """;

        Message sqsMessage = Message.builder()
            .body(messageBody)
            .receiptHandle("receipt-to-delete")
            .build();

        ReceiveMessageResponse response = ReceiveMessageResponse.builder()
            .messages(sqsMessage)
            .build();

        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(response))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockSqsAsyncClient.deleteMessage(any(DeleteMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(DeleteMessageResponse.builder().build()));

        // Capture the callback so we can trigger ack
        AtomicInteger routedCount = new AtomicInteger(0);
        when(mockQueueManager.routeMessageBatch(anyList())).thenAnswer(invocation -> {
            MessageCallback callback = invocation.getArgument(1);
            MessagePointer message = invocation.getArgument(0);
            // Simulate successful processing - ACK the message
            callback.ack(message);
            routedCount.incrementAndGet();
            return true;
        });

        // When
        asyncConsumer.start();

        // Then
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            assertTrue(routedCount.get() > 0, "Message should be routed");
            verify(mockSqsAsyncClient, atLeastOnce()).deleteMessage(
                argThat((DeleteMessageRequest request) ->
                    request.queueUrl().equals(queueUrl) &&
                    request.receiptHandle().equals("receipt-to-delete")
                )
            );
        });
    }

    @Test
    void shouldHandleInvalidJson() {
        // Given
        String invalidJson = "{ invalid json }";

        Message sqsMessage = Message.builder()
            .body(invalidJson)
            .receiptHandle("receipt-invalid")
            .build();

        ReceiveMessageResponse response = ReceiveMessageResponse.builder()
            .messages(sqsMessage)
            .build();

        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(response))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockSqsAsyncClient.deleteMessage(any(DeleteMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(DeleteMessageResponse.builder().build()));

        // When
        asyncConsumer.start();

        // Then - message should be ACKed to remove poison pill
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            verify(mockWarningService).addWarning(
                eq("MALFORMED_MESSAGE"),
                eq("WARN"),
                contains("Malformed message"),
                eq("AbstractQueueConsumer")
            );
            verify(mockSqsAsyncClient, atLeastOnce()).deleteMessage(
                argThat((DeleteMessageRequest req) -> req.queueUrl().equals(queueUrl))
            );
        });
    }

    @Test
    void shouldContinuePollingAfterErrors() {
        // Given - first poll fails, second succeeds
        String messageBody = """
            {
                "id": "recovery-msg",
                "poolCode": "POOL-A",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test"
            }
            """;

        Message sqsMessage = Message.builder()
            .body(messageBody)
            .receiptHandle("receipt-recovery")
            .build();

        ReceiveMessageResponse successResponse = ReceiveMessageResponse.builder()
            .messages(sqsMessage)
            .build();

        CompletableFuture<ReceiveMessageResponse> failedFuture = new CompletableFuture<>();
        failedFuture.completeExceptionally(new RuntimeException("Temporary SQS error"));

        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(failedFuture) // First call fails
            .thenReturn(CompletableFuture.completedFuture(successResponse)) // Second call succeeds
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockQueueManager.routeMessageBatch(anyList())).thenReturn(true);

        // When
        asyncConsumer.start();

        // Then - should recover and process message after error
        await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
            verify(mockQueueManager, atLeastOnce()).routeMessageBatch(
                any(MessagePointer.class),
                any(MessageCallback.class)
            );
        });
    }

    @Test
    @org.junit.jupiter.api.Disabled("Timing issues with shutdown test - async shutdown works but test is flaky")
    void shouldStopGracefullyAwaitingActivePolls() {
        // Given - mock returns empty responses (simpler test)
        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        asyncConsumer.start();

        // Wait for polling to start
        await().atMost(3, TimeUnit.SECONDS).untilAsserted(() ->
            verify(mockSqsAsyncClient, atLeastOnce()).receiveMessage(any(ReceiveMessageRequest.class))
        );

        // When - stop consumer
        asyncConsumer.stop();

        // Then - should stop gracefully within reasonable time
        await().atMost(10, TimeUnit.SECONDS).untilAsserted(() ->
            assertTrue(asyncConsumer.isFullyStopped(), "Consumer should be fully stopped")
        );
    }

    @Test
    void shouldUpdateHeartbeatDuringPolling() {
        // Given
        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        // When
        asyncConsumer.start();

        // Then - heartbeat should be updated
        await().atMost(3, TimeUnit.SECONDS).untilAsserted(() -> {
            long lastPollTime = asyncConsumer.getLastPollTime();
            assertTrue(lastPollTime > 0, "Heartbeat should be updated");
            assertTrue(asyncConsumer.isHealthy(), "Consumer should be healthy");
        });
    }

    @Test
    void shouldHandleMessageVisibilityControlAsync() {
        // Given
        String messageBody = """
            {
                "id": "visibility-msg",
                "poolCode": "POOL-A",
                "authToken": "test-token",
                "mediationType": "HTTP",
                "mediationTarget": "http://localhost:8080/test"
            }
            """;

        Message sqsMessage = Message.builder()
            .body(messageBody)
            .receiptHandle("receipt-visibility")
            .build();

        ReceiveMessageResponse response = ReceiveMessageResponse.builder()
            .messages(sqsMessage)
            .build();

        when(mockSqsAsyncClient.receiveMessage(any(ReceiveMessageRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(response))
            .thenReturn(CompletableFuture.completedFuture(
                ReceiveMessageResponse.builder().messages(List.of()).build()
            ));

        when(mockSqsAsyncClient.changeMessageVisibility(any(ChangeMessageVisibilityRequest.class)))
            .thenReturn(CompletableFuture.completedFuture(
                ChangeMessageVisibilityResponse.builder().build()
            ));

        // Capture callback and test visibility control
        when(mockQueueManager.routeMessageBatch(anyList())).thenAnswer(invocation -> {
            tech.flowcatalyst.messagerouter.callback.MessageVisibilityControl callback =
                (tech.flowcatalyst.messagerouter.callback.MessageVisibilityControl) invocation.getArgument(1);
            MessagePointer message = invocation.getArgument(0);

            // Test fast-fail visibility
            callback.setFastFailVisibility(message);

            // Test reset visibility
            callback.resetVisibilityToDefault(message);

            return true;
        });

        // When
        asyncConsumer.start();

        // Then
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            // Verify visibility timeout was changed (fast-fail = 1s, reset = 30s)
            verify(mockSqsAsyncClient, times(2)).changeMessageVisibility(
                any(ChangeMessageVisibilityRequest.class)
            );
        });
    }

    @Test
    void shouldReturnCorrectQueueIdentifier() {
        assertEquals(queueUrl, asyncConsumer.getQueueIdentifier());
    }
}
